export const metadata = {
  title: `${pageNumber} Migrations`,
}

# {metadata.title}

In this chapter, you'll learn what a migration is and how to generate a migration or write it manually.

## What is a Migration?

A migration is a TypeScript or JavaScript file that defines database changes made by a module. Migrations are useful when you re-use a module or you're working in a team, so that when one member of a team makes a database change, everyone else can reflect it on their side by running the migrations.

The migration's file has a class with two methods:

- The `up` method reflects changes on the database.
- The `down` method reverts the changes made in the `up` method.

---

## Generate Migration

Instead of you writing the migration manually, the Medusa CLI tool provides a [db:generate](!resources!/medusa-cli/commands/db#dbgenerate) command to generate a migration for a modules' data models.

For example, assuming you have a `blog` Module, you can generate a migration for it by running the following command:

```bash
npx medusa db:generate blog
```

This generates a migration file under the `migrations` directory of the Blog Module. You can then run it to reflect the changes in the database as mentioned in [this section](#run-the-migration).

---

## Write a Migration Manually

You can also write migrations manually. To do that, create a file in the `migrations` directory of the module and in it, a class that has an `up` and `down` method. The class's name should be of the format `Migration{YEAR}{MONTH}{DAY}{HOUR}{MINUTE}.ts` to ensure migrations are ran in the correct order.

For example:

<Note>

As of [Medusa v2.11.0](https://github.com/medusajs/medusa/releases/tag/v2.11.0), MikroORM dependencies are included in the `@medusajs/framework` package. If you're using an older version of Medusa, change the import statement to `@mikro-orm/migrations`.

</Note>

```ts title="src/modules/blog/migrations/Migration202507021059_create_author.ts"
import { Migration } from "@medusajs/framework/mikro-orm/migrations"

export class Migration202507021059 extends Migration {

  async up(): Promise<void> {
    this.addSql("create table if not exists \"author\" (\"id\" text not null, \"name\" text not null, \"created_at\" timestamptz not null default now(), \"updated_at\" timestamptz not null default now(), \"deleted_at\" timestamptz null, constraint \"author_pkey\" primary key (\"id\"));")
  }

  async down(): Promise<void> {
    this.addSql("drop table if exists \"author\" cascade;")
  }

}
```

The migration class in the file extends the `Migration` class imported from `@medusajs/framework/mikro-orm/migrations`. In the `up` and `down` method of the migration class, you use the `addSql` method provided by MikroORM's `Migration` class to run PostgreSQL syntax.

In the example above, the `up` method creates the table `author`, and the `down` method drops the table if the migration is reverted.

<Note title="Tip">

Refer to [MikroORM's documentation](https://mikro-orm.io/docs/migrations#migration-class) for more details on writing migrations.

</Note>

### Migration File Naming

Migrations are executed in the ascending order of their file names. So, it's recommended to prefix the migration file name with the timestamp of when the migration was created. This ensures that migrations are executed in the order they were created.

For example, if you create a migration on July 2, 2025, at 10:59 AM, the file name should be `Migration202507021059_create_brand.ts`. This way, the migration will be executed after any previous migrations that were created before this date and time.

---

## Run the Migration

To run your migration, run the following command:

<Note>

This command also syncs module links. If you don't want that, use the `--skip-links` option.

</Note>

```bash
npx medusa db:migrate
```

This reflects the changes in the database as implemented in the migration's `up` method.

---

## Rollback the Migration

To rollback or revert the last migration you ran for a module, run the following command:

```bash
npx medusa db:rollback blog
```

This rolls back the last ran migration on the Blog Module.

### Caution: Rollback Migration before Deleting

If you need to delete a migration file, make sure to rollback the migration first. Otherwise, you might encounter issues when generating and running new migrations.

For example, if you delete the migration of the Blog Module, then try to create a new one, Medusa will create a brand new migration that re-creates the tables or indices. If those are still in the database, you might encounter errors.

So, always rollback the migration before deleting it.

---

## More Database Commands

To learn more about the Medusa CLI's database commands, refer to [this CLI reference](!resources!/medusa-cli/commands/db).

---

## Data Migration Scripts

In some use cases, you may need to perform data migration after updates to the database. For example, after you added a `Site` data model to the Blog Module, you want to assign all existing posts and authors to a default site. Another example is updating data stored in a third-party system.

In those scenarios, you can instead create a data migration script. They are asynchronous function that the Medusa application executes once when you run the `npx medusa db:migrate command`.

### How to Create a Data Migration Script

You can create data migration scripts in a TypeScript or JavaScript file under the `src/migration-scripts` directory. The file must export an asynchronous function that will be executed when the `db:migrate` command is executed.

For example, to create a data migration script for the Blog Module example, create the file `src/migration-scripts/migrate-blog-data.ts` with the following content:

export const dataMigrationHighlights = [
  ["6", "migrateBlogData", "Function to execute when migrations are run"],
  ["8", "isInstalled", "Confirm that the Blog Module is installed before running the workflow."],
  ["12", "migrateBlogDataWorkflow", "Perform the data migration action."],
]

```ts title="src/migration-scripts/migrate-blog-data.ts" highlights={dataMigrationHighlights}
import { MedusaModule } from "@medusajs/framework/modules-sdk"
import { ExecArgs } from "@medusajs/framework/types"
import { BLOG_MODULE } from "../modules/blog"
import { createWorkflow } from "@medusajs/framework/workflows-sdk"

export default async function migrateBlogData({ container }: ExecArgs) {
  // Check that the blog module exists
  if (!MedusaModule.isInstalled(BLOG_MODULE)) {
    return
  }

  await migrateBlogDataWorkflow(container).run({})
}

const migrateBlogDataWorkflow = createWorkflow(
  "migrate-blog-data",
  () => {
    // Assuming you have these steps
    createDefaultSiteStep()

    assignBlogDataToSiteStep()
  }
)
```

In the above example, you default export an asynchronous function that receives an object parameter with the [Medusa Container](../../medusa-container/page.mdx) property.

In the function, you first ensure that the Blog Module is installed to avoid errors otherwise. Then, you run a workflow that you've created in the same file that performs the necessary data migration.

#### Test Data Migration Script

To test out the data migration script, run the migration command:

```bash
npx medusa db:migrate
```

Medusa will run any pending migrations and migration scripts, including your script.

If the script runs successfully, Medusa won't run the script again.

If there are errors in the script, you'll receive an error in the migration script logs. Medusa will keep running the script every time you run the migration command until it runs successfully.

---

## Migration Examples

The following section provides examples of writing migrations for common database changes.

### Example: Migration with Relationship

Consider you have a module with two data models: `Author` and `Post`. An author can have multiple posts, so there's a one-to-many relationship between the two models:

```ts
import { model } from "@medusajs/framework/utils"

const Post = model.define("post", {
  id: model.id().primaryKey(),
  title: model.text(),
  author: model.belongsTo(() => Author, {
    mappedBy: "posts",
  }),
})

const Author = model.define("author", {
  id: model.id().primaryKey(),
  name: model.text(),
  posts: model.hasMany(() => Post, {
    mappedBy: "author",
  }),
})
```

To create a migration that reflects this relationship in the database, you can create a migration file as follows:

```ts title="src/modules/blog/migrations/Migration202507021200_create_author_and_post.ts"
import { Migration } from "@medusajs/framework/mikro-orm/migrations"

export class Migration20251230112505 extends Migration {

  override async up(): Promise<void> {
    this.addSql(`create table if not exists "author" ("id" text not null, "name" text not null, "created_at" timestamptz not null default now(), "updated_at" timestamptz not null default now(), "deleted_at" timestamptz null, constraint "author_pkey" primary key ("id"));`)
    this.addSql(`CREATE INDEX IF NOT EXISTS "IDX_author_deleted_at" ON "author" ("deleted_at") WHERE deleted_at IS NULL;`)

    this.addSql(`create table if not exists "post" ("id" text not null, "title" text not null, "author_id" text not null, "created_at" timestamptz not null default now(), "updated_at" timestamptz not null default now(), "deleted_at" timestamptz null, constraint "post_pkey" primary key ("id"));`)
    this.addSql(`CREATE INDEX IF NOT EXISTS "IDX_post_author_id" ON "post" ("author_id") WHERE deleted_at IS NULL;`)
    this.addSql(`CREATE INDEX IF NOT EXISTS "IDX_post_deleted_at" ON "post" ("deleted_at") WHERE deleted_at IS NULL;`)

    this.addSql(`alter table if exists "post" add constraint "post_author_id_foreign" foreign key ("author_id") references "author" ("id") on update cascade;`)
  }

  override async down(): Promise<void> {
    this.addSql(`alter table if exists "post" drop constraint if exists "post_author_id_foreign";`)

    this.addSql(`drop table if exists "author" cascade;`)

    this.addSql(`drop table if exists "post" cascade;`)
  }

}
```

In this migration, the `up` method creates the `author` and `post` tables, including the foreign key constraint that establishes the relationship between them. The `down` method removes the foreign key constraint and drops both tables.

### Example: Migration to Add a New Column

Consider you have an existing `Post` data model, and you added a new `published_at` column to it.

You can create a migration file to add this new column as follows:

```ts title="src/modules/blog/migrations/Migration202507021300_add_published_at_to_post.ts"
import { Migration } from "@medusajs/framework/mikro-orm/migrations"

export class Migration20251230113025 extends Migration {

  override async up(): Promise<void> {
    this.addSql(`alter table if exists "post" add column if not exists "published_at" timestamptz null;`)
  }

  override async down(): Promise<void> {
    this.addSql(`alter table if exists "post" drop column if exists "published_at";`)
  }

}
```

In this migration, the `up` method adds the `published_at` column to the `post` table, while the `down` method removes it.

### Example: Migration to Remove a Column

Consider you have an existing `Post` data model, and you removed the `published_at` column from it.

You can create a migration file to remove this column as follows:

```ts title="src/modules/blog/migrations/Migration202507021400_remove_published_at_from_post.ts"
import { Migration } from "@medusajs/framework/mikro-orm/migrations"

export class Migration20251230113125 extends Migration {

  override async up(): Promise<void> {
    this.addSql(`alter table if exists "post" drop column if exists "published_at";`)
  }

  override async down(): Promise<void> {
    this.addSql(`alter table if exists "post" add column if not exists "published_at" timestamptz null;`)
  }

}
```

In this migration, the `up` method removes the `published_at` column from the `post` table, while the `down` method adds it back.

### Example: Migration to Rename a Column

Consider you have an existing `Post` data model with a `title` column, and you renamed it to `headline`.

You can create a migration file to rename this column as follows:

```ts title="src/modules/blog/migrations/Migration202507021500_rename_title_to_headline_in_post.ts"
import { Migration } from "@medusajs/framework/mikro-orm/migrations"

export class Migration20251230113214 extends Migration {

  override async up(): Promise<void> {
    this.addSql(`alter table if exists "post" rename column "title" to "headline";`)
  }

  override async down(): Promise<void> {
    this.addSql(`alter table if exists "post" rename column "headline" to "title";`)
  }

}
```

In this migration, the `up` method renames the `title` column to `headline` in the `post` table, while the `down` method renames it back to `title`.

### Example: Migration to Create an Index

Consider you have an existing `Post` data model, and add an index on the `headline` column to improve query performance:

export const indexHighlights = [
  ["6", "index", "Define the index on the 'headline' column"],
]

```ts title="src/modules/blog/models/post.ts" highlights={indexHighlights}
import { model } from "@medusajs/framework/utils"
import { Author } from "./author"

export const Post = model.define("post", {
  id: model.id().primaryKey(),
  headline: model.text().index(),
  author: model.belongsTo(() => Author, {
    mappedBy: "posts",
  }),
})
```

You can create a migration file to create this index as follows:

```ts title="src/modules/blog/migrations/Migration202507021600_create_index_on_headline_in_post.ts"
import { Migration } from "@medusajs/framework/mikro-orm/migrations"

export class Migration20251230113322 extends Migration {

  override async up(): Promise<void> {
    this.addSql(`CREATE INDEX IF NOT EXISTS "IDX_post_headline" ON "post" ("headline") WHERE deleted_at IS NULL;`)
  }

  override async down(): Promise<void> {
    this.addSql(`drop index if exists "IDX_post_headline";`)
  }

}
```

In this migration, the `up` method creates an index on the `headline` column of the `post` table, while the `down` method removes the index.

### Example: Migration to Drop an Index

Consider you have an existing `Post` data model with an index on the `headline` column, and you decide to remove this index.

You can create a migration file to drop this index as follows:

```ts title="src/modules/blog/migrations/Migration202507021700_drop_index_on_headline_in_post.ts"
import { Migration } from "@medusajs/framework/mikro-orm/migrations"

export class Migration20251230113350 extends Migration {

  override async up(): Promise<void> {
    this.addSql(`drop index if exists "IDX_post_headline";`)
  }

  override async down(): Promise<void> {
    this.addSql(`CREATE INDEX IF NOT EXISTS "IDX_post_headline" ON "post" ("headline") WHERE deleted_at IS NULL;`)
  }

}
```

In this migration, the `up` method drops the index on the `headline` column of the `post` table, while the `down` method recreates the index.
