import {
  IDistributedSchedulerStorage,
  SchedulerOptions,
  WorkflowManager,
  WorkflowScheduler,
} from "@medusajs/orchestration"
import { IEventBusModuleService } from "@medusajs/types"
import {
  composeMessage,
  createMedusaContainer,
  Modules,
  promiseAll,
} from "@medusajs/utils"
import { asValue } from "@medusajs/deps/awilix"
import { setTimeout } from "timers/promises"
import {
  createStep,
  createWorkflow,
  parallelize,
  StepFunction,
  StepResponse,
  transform,
  when,
  WorkflowResponse,
} from ".."
import { MedusaWorkflow } from "../../../medusa-workflow"
import { createHook } from "../create-hook"

jest.setTimeout(30000)

class MockSchedulerStorage implements IDistributedSchedulerStorage {
  async schedule(
    jobDefinition: string | { jobId: string },
    schedulerOptions: SchedulerOptions
  ): Promise<void> {
    return Promise.resolve()
  }
  async remove(jobId: string): Promise<void> {
    return Promise.resolve()
  }
  async removeAll(): Promise<void> {
    return Promise.resolve()
  }
}

WorkflowScheduler.setStorage(new MockSchedulerStorage())

const afterEach_ = () => {
  jest.clearAllMocks()
  MedusaWorkflow.workflows = {}
  WorkflowManager.unregisterAll()
}

describe("Workflow composer", function () {
  afterEach(afterEach_)

  describe("Using steps returning plain values", function () {
    afterEach(afterEach_)

    it("should compose a workflow and pass down the event group id provided as part of the context", async () => {
      let context
      const mockStep1Fn = jest
        .fn()
        .mockImplementation((input, { context: stepContext }) => {
          context = stepContext
        })

      const step1 = createStep("step1", mockStep1Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        step1(input)
      })

      await workflow().run({
        context: {
          eventGroupId: "event-group-id",
        },
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(1)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(context.eventGroupId).toEqual("event-group-id")
    })

    it("should compose a workflow and pass down the autogenerated event group id if not provided as part of the context", async () => {
      let context
      const mockStep1Fn = jest
        .fn()
        .mockImplementation((input, { context: stepContext }) => {
          context = stepContext
        })

      const step1 = createStep("step1", mockStep1Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        step1(input)
      })

      await workflow().run({})

      expect(mockStep1Fn).toHaveBeenCalledTimes(1)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(context.eventGroupId).toBeTruthy()
    })

    it("should compose a new workflow composed retryable steps", async () => {
      const maxRetries = 1

      const mockStep1Fn = jest.fn().mockImplementation((input, context) => {
        const attempt = context.metadata.attempt || 0
        if (attempt <= maxRetries) {
          throw new Error("test error")
        }

        return { inputs: [input], obj: "return from 1" }
      })

      const step1 = createStep({ name: "step1", maxRetries }, mockStep1Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        return new WorkflowResponse(step1(input))
      })

      const workflowInput = { test: "payload1" }
      const { result: workflowResult } = await workflow().run({
        input: workflowInput,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(2)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)
      expect(mockStep1Fn.mock.calls[1][0]).toEqual(workflowInput)

      expect(workflowResult).toEqual({
        inputs: [{ test: "payload1" }],
        obj: "return from 1",
      })
    })

    it("should compose a new workflow and execute it", async () => {
      const mockStep1Fn = jest.fn().mockImplementation((input) => {
        return { inputs: [input], obj: "return from 1" }
      })
      const mockStep2Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return {
          inputs,
          obj: "return from 2",
        }
      })
      const mockStep3Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return {
          inputs,
          obj: "return from 3",
        }
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        const returnStep1 = step1(input)
        const ret2 = step2(returnStep1)
        return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
      })

      const workflowInput = { test: "payload1" }
      const { result: workflowResult } = await workflow().run({
        input: workflowInput,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(1)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)

      expect(mockStep2Fn).toHaveBeenCalledTimes(1)
      expect(mockStep2Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep2Fn.mock.calls[0][0]).toEqual({
        inputs: [workflowInput],
        obj: "return from 1",
      })

      expect(mockStep3Fn).toHaveBeenCalledTimes(1)
      expect(mockStep3Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        one: {
          inputs: [workflowInput],
          obj: "return from 1",
        },
        two: {
          inputs: [
            {
              inputs: [workflowInput],
              obj: "return from 1",
            },
          ],
          obj: "return from 2",
        },
      })

      expect(workflowResult).toEqual({
        inputs: [
          {
            one: {
              inputs: [workflowInput],
              obj: "return from 1",
            },
            two: {
              inputs: [
                {
                  inputs: [workflowInput],
                  obj: "return from 1",
                },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
    })

    it("should compose two new workflows sequentially and execute them sequentially", async () => {
      const mockStep1Fn = jest.fn().mockImplementation((input, context) => {
        return { inputs: [input], obj: "return from 1" }
      })
      const mockStep2Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return {
          inputs,
          obj: "return from 2",
        }
      })
      const mockStep3Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return {
          inputs,
          obj: "return from 3",
        }
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        const returnStep1 = step1(input)
        const ret2 = step2(returnStep1)
        return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
      })

      const workflow2 = createWorkflow("workflow2", function (input) {
        const returnStep1 = step1(input)
        const ret2 = step2(returnStep1)
        return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
      })

      const workflowInput = { test: "payload1" }
      const { result: workflowResult } = await workflow().run({
        input: workflowInput,
      })

      const workflow2Input = { test: "payload2" }
      const { result: workflow2Result } = await workflow2().run({
        input: workflow2Input,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(2)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)
      expect(mockStep1Fn.mock.calls[1][0]).toEqual(workflow2Input)

      expect(mockStep2Fn).toHaveBeenCalledTimes(2)
      expect(mockStep2Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep2Fn.mock.calls[0][0]).toEqual({
        inputs: [{ test: "payload1" }],
        obj: "return from 1",
      })
      expect(mockStep2Fn.mock.calls[1][0]).toEqual({
        inputs: [{ test: "payload2" }],
        obj: "return from 1",
      })

      expect(mockStep3Fn).toHaveBeenCalledTimes(2)
      expect(mockStep3Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
        two: {
          inputs: [{ inputs: [{ test: "payload1" }], obj: "return from 1" }],
          obj: "return from 2",
        },
      })
      expect(mockStep3Fn.mock.calls[1][0]).toEqual({
        one: { inputs: [{ test: "payload2" }], obj: "return from 1" },
        two: {
          inputs: [{ inputs: [{ test: "payload2" }], obj: "return from 1" }],
          obj: "return from 2",
        },
      })

      expect(workflowResult).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload1" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
      expect(workflow2Result).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload2" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload2" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
    })

    it("should compose two new workflows concurrently and execute them sequentially", async () => {
      const mockStep1Fn = jest.fn().mockImplementation((input, context) => {
        return { inputs: [input], obj: "return from 1" }
      })
      const mockStep2Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return {
          inputs,
          obj: "return from 2",
        }
      })
      const mockStep3Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return {
          inputs,
          obj: "return from 3",
        }
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)

      const [workflow, workflow2] = await promiseAll([
        createWorkflow("workflow1", function (input) {
          const returnStep1 = step1(input)
          const ret2 = step2(returnStep1)
          return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
        }),

        createWorkflow("workflow2", function (input) {
          const returnStep1 = step1(input)
          const ret2 = step2(returnStep1)
          return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
        }),
      ])

      const workflowInput = { test: "payload1" }
      const { result: workflowResult } = await workflow().run({
        input: workflowInput,
      })

      const workflow2Input = { test: "payload2" }
      const { result: workflow2Result } = await workflow2().run({
        input: workflow2Input,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(2)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)
      expect(mockStep1Fn.mock.calls[1][0]).toEqual(workflow2Input)

      expect(mockStep2Fn).toHaveBeenCalledTimes(2)
      expect(mockStep2Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep2Fn.mock.calls[0][0]).toEqual({
        inputs: [workflowInput],
        obj: "return from 1",
      })
      expect(mockStep2Fn.mock.calls[1][0]).toEqual({
        inputs: [workflow2Input],
        obj: "return from 1",
      })

      expect(mockStep3Fn).toHaveBeenCalledTimes(2)
      expect(mockStep3Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
        two: {
          inputs: [{ inputs: [{ test: "payload1" }], obj: "return from 1" }],
          obj: "return from 2",
        },
      })
      expect(mockStep3Fn.mock.calls[1][0]).toEqual({
        one: { inputs: [{ test: "payload2" }], obj: "return from 1" },
        two: {
          inputs: [{ inputs: [{ test: "payload2" }], obj: "return from 1" }],
          obj: "return from 2",
        },
      })

      expect(workflowResult).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload1" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
      expect(workflow2Result).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload2" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload2" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
    })

    it("should compose two new workflows concurrently and execute them concurrently", async () => {
      const mockStep1Fn = jest.fn().mockImplementation((input, context) => {
        return { inputs: [input], obj: "return from 1" }
      })
      const mockStep2Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return {
          inputs,
          obj: "return from 2",
        }
      })
      const mockStep3Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return {
          inputs,
          obj: "return from 3",
        }
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)

      const [workflow, workflow2] = await promiseAll([
        createWorkflow("workflow1", function (input) {
          const returnStep1 = step1(input)
          const ret2 = step2(returnStep1)
          return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
        }),

        createWorkflow("workflow2", function (input) {
          const returnStep1 = step1(input)
          const ret2 = step2(returnStep1)
          return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
        }),
      ])

      const workflowInput = { test: "payload1" }
      const workflow2Input = { test: "payload2" }

      const [{ result: workflowResult }, { result: workflow2Result }] =
        await promiseAll([
          workflow().run({
            input: workflowInput,
          }),
          workflow2().run({
            input: workflow2Input,
          }),
        ])

      expect(mockStep1Fn).toHaveBeenCalledTimes(2)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)
      expect(mockStep1Fn.mock.calls[1][0]).toEqual(workflow2Input)
      expect(mockStep1Fn.mock.calls[1]).toHaveLength(2)

      expect(mockStep2Fn).toHaveBeenCalledTimes(2)
      expect(mockStep2Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep2Fn.mock.calls[0][0]).toEqual({
        inputs: [workflowInput],
        obj: "return from 1",
      })
      expect(mockStep2Fn.mock.calls[1][0]).toEqual({
        inputs: [workflow2Input],
        obj: "return from 1",
      })

      expect(mockStep3Fn).toHaveBeenCalledTimes(2)
      expect(mockStep3Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
        two: {
          inputs: [{ inputs: [{ test: "payload1" }], obj: "return from 1" }],
          obj: "return from 2",
        },
      })
      expect(mockStep3Fn.mock.calls[1][0]).toEqual({
        one: { inputs: [{ test: "payload2" }], obj: "return from 1" },
        two: {
          inputs: [{ inputs: [{ test: "payload2" }], obj: "return from 1" }],
          obj: "return from 2",
        },
      })

      expect(workflowResult).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload1" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
      expect(workflow2Result).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload2" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload2" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
    })

    it("should compose a new workflow and execute it multiple times concurrently", async () => {
      const mockStep1Fn = jest
        .fn()
        .mockImplementation(function (input, context) {
          return { inputs: [input], obj: "return from 1" }
        })
      const mockStep2Fn = jest.fn().mockImplementation(function (...inputs) {
        inputs.pop()
        return {
          inputs,
          obj: "return from 2",
        }
      })
      const mockStep3Fn = jest.fn().mockImplementation(function (...inputs) {
        inputs.pop()
        return {
          inputs,
          obj: "return from 3",
        }
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        const returnStep1 = step1(input)
        const ret2 = step2(returnStep1)
        return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
      })

      const workflowInput = { test: "payload1" }
      const workflowInput2 = { test: "payload2" }

      const [{ result: workflowResult }, { result: workflowResult2 }] =
        await promiseAll([
          workflow().run({
            input: workflowInput,
          }),
          workflow().run({
            input: workflowInput2,
          }),
        ])

      expect(mockStep1Fn).toHaveBeenCalledTimes(2)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)
      expect(mockStep1Fn.mock.calls[1]).toHaveLength(2)

      expect(mockStep2Fn).toHaveBeenCalledTimes(2)
      expect(mockStep2Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep2Fn.mock.calls[0][0]).toEqual({
        inputs: [workflowInput],
        obj: "return from 1",
      })

      expect(mockStep3Fn).toHaveBeenCalledTimes(2)
      expect(mockStep3Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
        two: {
          inputs: [{ inputs: [{ test: "payload1" }], obj: "return from 1" }],
          obj: "return from 2",
        },
      })

      expect(workflowResult).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload1" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
      expect(workflowResult2).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload2" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload2" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
    })

    it("should compose a new workflow with parallelize steps", async () => {
      const mockStep1Fn = jest.fn().mockImplementation((input, context) => {
        return { inputs: [input], obj: "return from 1" }
      })
      const mockStep2Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return {
          inputs,
          obj: "return from 2",
        }
      })
      const mockStep3Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return {
          inputs,
          obj: "return from 3",
        }
      })
      const mockStep4Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return {
          inputs,
          obj: "return from 4",
        }
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)
      const step4 = createStep("step4", mockStep4Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        const returnStep1 = step1(input)
        const [ret2, ret3] = parallelize(step2(returnStep1), step3(returnStep1))
        return new WorkflowResponse(step4({ one: ret2, two: ret3 }))
      })

      const workflowInput = { test: "payload1" }
      const { result: workflowResult } = await workflow().run({
        input: workflowInput,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(1)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)

      expect(mockStep2Fn).toHaveBeenCalledTimes(1)
      expect(mockStep2Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep2Fn.mock.calls[0][0]).toEqual({
        inputs: [workflowInput],
        obj: "return from 1",
      })

      expect(mockStep3Fn).toHaveBeenCalledTimes(1)
      expect(mockStep3Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        inputs: [workflowInput],
        obj: "return from 1",
      })

      expect(mockStep4Fn).toHaveBeenCalledTimes(1)
      expect(mockStep4Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep4Fn.mock.calls[0][0]).toEqual({
        one: {
          inputs: [{ inputs: [{ test: "payload1" }], obj: "return from 1" }],
          obj: "return from 2",
        },
        two: {
          inputs: [{ inputs: [{ test: "payload1" }], obj: "return from 1" }],
          obj: "return from 3",
        },
      })

      expect(workflowResult).toEqual({
        inputs: [
          {
            one: {
              inputs: [
                { inputs: [{ test: "payload1" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
            two: {
              inputs: [
                { inputs: [{ test: "payload1" }], obj: "return from 1" },
              ],
              obj: "return from 3",
            },
          },
        ],
        obj: "return from 4",
      })
    })

    it("should compose a new workflow with conditional parallelized steps", async () => {
      const stepResults: string[] = []

      const mockStep1Fn = jest.fn().mockImplementation(async () => {
        await setTimeout(100)
        stepResults.push("step1")
        return new StepResponse(true)
      }) as any
      const mockStep2Fn = jest.fn().mockImplementation(() => {
        stepResults.push("step2")
        return new StepResponse(true)
      }) as any
      const mockStep3Fn = jest.fn().mockImplementation(() => {
        stepResults.push("step3")
        return new StepResponse(true)
      }) as any
      const mockStep4Fn = jest.fn().mockImplementation(() => {
        stepResults.push("step4")
        return new StepResponse(true)
      }) as any

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)
      const step4 = createStep("step4", mockStep4Fn)

      const callStep2IfNeeded = () => {
        return when({}, () => false).then(() => {
          return step2()
        })
      }

      const callStep3IfNeeded = () => {
        return when({}, () => false).then(() => {
          return step4()
        })
      }

      const workflow = createWorkflow("workflow1", function (input) {
        const [ret1, ret2, ret3, ret4] = parallelize(
          step1(),
          callStep2IfNeeded(),
          step3(),
          callStep3IfNeeded()
        )
        return new WorkflowResponse({ ret1, ret2, ret3, ret4 })
      })

      const { result: workflowResult } = await workflow().run()

      expect(mockStep1Fn).toHaveBeenCalledTimes(1)
      expect(mockStep2Fn).toHaveBeenCalledTimes(0)
      expect(mockStep3Fn).toHaveBeenCalledTimes(1)
      expect(mockStep4Fn).toHaveBeenCalledTimes(0)

      expect(workflowResult).toEqual({
        ret1: true,
        ret2: undefined,
        ret3: true,
        ret4: undefined,
      })

      expect(stepResults).toEqual(["step3", "step1"])
    })

    it("should compose a new workflow with conditional steps", async () => {
      const stepResults: string[] = []

      let hookCalled = jest.fn()
      let timesExecuted = 0
      const mockStep1Fn = jest.fn().mockImplementation(async () => {
        timesExecuted += 1
        stepResults.push("step1")
        return new StepResponse(true)
      }) as any
      const mockStep2Fn = jest.fn().mockImplementation(() => {
        stepResults.push("step2")
        return new StepResponse(true)
      }) as any

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)

      const workflow = createWorkflow(
        "workflow1",
        function (input: { timesExecuted: number }) {
          const ret = when("cond", input, ({ timesExecuted }) => {
            return timesExecuted < 2
          }).then(() => {
            createHook("validate", {
              executed: input.timesExecuted,
            })
            const ret1 = step1()
            const ret2 = step2()
            const parallelized = parallelize(ret1, ret2)

            return [ret1, ret2, parallelized]
          })

          return new WorkflowResponse(ret)
        }
      )

      ;(workflow.hooks as any).validate((input) => {
        hookCalled(input)
      })

      const { result: workflowResult } = await workflow().run({
        input: {
          timesExecuted,
        },
      })

      const { result: workflowResultSecondTime } = await workflow().run({
        input: {
          timesExecuted,
        },
      })

      const { result: workflowResultThirdTime } = await workflow().run({
        input: {
          timesExecuted,
        },
      })

      const { result: workflowResultFourthTime } = await workflow().run({
        input: {
          timesExecuted,
        },
      })

      expect(hookCalled).toHaveBeenCalledTimes(2)
      expect(mockStep1Fn).toHaveBeenCalledTimes(2)
      expect(mockStep2Fn).toHaveBeenCalledTimes(2)

      expect(workflowResult).toEqual([true, true, [true, true]])

      expect(workflowResultSecondTime).toEqual([true, true, [true, true]])

      expect(workflowResultThirdTime).toEqual(undefined)

      expect(workflowResultFourthTime).toEqual(undefined)

      expect(stepResults).toEqual(["step1", "step2", "step1", "step2"])
    })

    it("should compose a new workflow with parallelize steps and rollback them all in case of error", async () => {
      const step1CompensationFn = jest.fn().mockImplementation(() => {
        return "step1 compensation"
      })
      const step2CompensationFn = jest.fn().mockImplementation(() => {
        return "step2 compensation"
      })
      const step3CompensationFn = jest.fn().mockImplementation(() => {
        return "step3 compensation"
      })
      const step4CompensationFn = jest.fn().mockImplementation(() => {
        return "step4 compensation"
      })
      const mockStep1Fn = jest.fn().mockImplementation(() => {
        return "step1"
      })
      const mockStep2Fn = jest.fn().mockImplementation(() => {
        return "step2"
      })
      const mockStep3Fn = jest.fn().mockImplementation(() => {
        return "step3"
      })
      const mockStep4Fn = jest.fn().mockImplementation(() => {
        throw new Error("An error occured in step 4.")
      })

      const step1 = createStep(
        "step1",
        mockStep1Fn as unknown as StepFunction<never, StepResponse<string>>,
        step1CompensationFn
      )
      const step2 = createStep(
        "step2",
        mockStep2Fn as unknown as StepFunction<never, StepResponse<string>>,
        step2CompensationFn
      )
      const step3 = createStep(
        "step3",
        mockStep3Fn as unknown as StepFunction<never, StepResponse<string>>,
        step3CompensationFn
      )
      const step4 = createStep(
        "step4",
        mockStep4Fn as unknown as StepFunction<never, StepResponse<void>>,
        step4CompensationFn
      )

      const workflow = createWorkflow("workflow1", function (input) {
        const [step1Res] = parallelize(step1(), step2(), step3(), step4())
        return new WorkflowResponse(step1Res)
      })

      await workflow.run({
        throwOnError: false,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(1)
      expect(mockStep2Fn).toHaveBeenCalledTimes(1)
      expect(mockStep3Fn).toHaveBeenCalledTimes(1)
      expect(mockStep4Fn).toHaveBeenCalledTimes(1)

      expect(step1CompensationFn).toHaveBeenCalledTimes(1)
      expect(step1CompensationFn.mock.calls[0][0]).toBe("step1")
      expect(step2CompensationFn).toHaveBeenCalledTimes(1)
      expect(step2CompensationFn.mock.calls[0][0]).toBe("step2")
      expect(step3CompensationFn).toHaveBeenCalledTimes(1)
      expect(step3CompensationFn.mock.calls[0][0]).toBe("step3")
      expect(step4CompensationFn).toHaveBeenCalledTimes(1)
      expect(step4CompensationFn.mock.calls[0][0]).not.toBeDefined()
    })

    it("should compose a new workflow with parallelize steps with config and rollback them all in case of error", async () => {
      const step1CompensationFn = jest.fn().mockImplementation(() => {
        return "step1 compensation"
      })
      const step2CompensationFn = jest.fn().mockImplementation(() => {
        return "step2 compensation"
      })
      const step3CompensationFn = jest.fn().mockImplementation(() => {
        return "step3 compensation"
      })
      const step4CompensationFn = jest.fn().mockImplementation(() => {
        return "step4 compensation"
      })
      const mockStep1Fn = jest.fn().mockImplementation(() => {
        return "step1"
      })
      const mockStep2Fn = jest.fn().mockImplementation(() => {
        return "step2"
      })
      const mockStep3Fn = jest.fn().mockImplementation(() => {
        return "step3"
      })
      const mockStep4Fn = jest.fn().mockImplementation(() => {
        throw new Error("An error occured in step 4.")
      })

      const step1 = createStep(
        "step1",
        mockStep1Fn as unknown as StepFunction<never, StepResponse<string>>,
        step1CompensationFn
      )
      const step2 = createStep(
        "step2",
        mockStep2Fn as unknown as StepFunction<never, StepResponse<string>>,
        step2CompensationFn
      )
      const step3 = createStep(
        "step3",
        mockStep3Fn as unknown as StepFunction<never, StepResponse<string>>,
        step3CompensationFn
      )
      const step4 = createStep(
        "step4",
        mockStep4Fn as unknown as StepFunction<never, StepResponse<void>>,
        step4CompensationFn
      )

      const workflow = createWorkflow("workflow1", function (input) {
        const [step1Res] = parallelize(
          step1().config({ name: "newStep1Name" }),
          step2(),
          step3(),
          step4()
        )
        return new WorkflowResponse(step1Res)
      })

      await workflow.run({
        throwOnError: false,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(1)
      expect(mockStep2Fn).toHaveBeenCalledTimes(1)
      expect(mockStep3Fn).toHaveBeenCalledTimes(1)
      expect(mockStep4Fn).toHaveBeenCalledTimes(1)

      expect(step1CompensationFn).toHaveBeenCalledTimes(1)
      expect(step1CompensationFn.mock.calls[0][0]).toBe("step1")
      expect(step2CompensationFn).toHaveBeenCalledTimes(1)
      expect(step2CompensationFn.mock.calls[0][0]).toBe("step2")
      expect(step3CompensationFn).toHaveBeenCalledTimes(1)
      expect(step3CompensationFn.mock.calls[0][0]).toBe("step3")
      expect(step4CompensationFn).toHaveBeenCalledTimes(1)
      expect(step4CompensationFn.mock.calls[0][0]).not.toBeDefined()
    })

    it("should transform the values before forward them to the next step", async () => {
      const mockStep1Fn = jest.fn().mockImplementation((obj, context) => {
        const ret = {
          property: "property",
        }
        return ret
      })

      const mockStep2Fn = jest.fn().mockImplementation((obj, context) => {
        const ret = {
          ...obj,
          sum: "sum = " + obj.sum,
        }

        return ret
      })

      const mockStep3Fn = jest.fn().mockImplementation((param, context) => {
        const ret = {
          avg: "avg = " + param.avg,
          ...param,
        }
        return ret
      })

      const transform1Fn = jest
        .fn()
        .mockImplementation(({ input, step1Result }) => {
          const newObj = {
            ...step1Result,
            ...input,
            sum: input.a + input.b,
          }
          return {
            input: newObj,
          }
        })

      const transform2Fn = jest
        .fn()
        .mockImplementation(async ({ input }, context) => {
          input.another_prop = "another_prop"
          return input
        })

      const transform3Fn = jest.fn().mockImplementation(({ obj }) => {
        obj.avg = (obj.a + obj.b) / 2

        return obj
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)

      const mainFlow = createWorkflow("test_", function (input) {
        const step1Result = step1(input)

        const sum = transform(
          { input, step1Result },
          transform1Fn,
          transform2Fn
        )

        const ret2 = step2(sum)

        const avg = transform({ obj: ret2 }, transform3Fn)

        return new WorkflowResponse(step3(avg))
      })

      const workflowInput = { a: 1, b: 2 }
      await mainFlow().run({ input: workflowInput })

      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)

      expect(mockStep2Fn.mock.calls[0][0]).toEqual({
        property: "property",
        a: 1,
        b: 2,
        sum: 3,
        another_prop: "another_prop",
      })

      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        sum: "sum = 3",
        property: "property",
        a: 1,
        b: 2,
        another_prop: "another_prop",
        avg: 1.5,
      })

      expect(transform1Fn).toHaveBeenCalledTimes(1)
      expect(transform2Fn).toHaveBeenCalledTimes(1)
      expect(transform3Fn).toHaveBeenCalledTimes(1)
    })

    it("should compose a new workflow and access properties from steps", async () => {
      const mockStep1Fn = jest.fn().mockImplementation(({ input }, context) => {
        return { id: input, product: "product_1", variant: "variant_2" }
      })
      const mockStep2Fn = jest.fn().mockImplementation(({ product }) => {
        return {
          product: "Saved product - " + product,
        }
      })
      const mockStep3Fn = jest.fn().mockImplementation(({ variant }) => {
        return {
          variant: "Saved variant - " + variant,
        }
      })

      const getData = createStep("step1", mockStep1Fn)
      const saveProduct = createStep("step2", mockStep2Fn)
      const saveVariant = createStep("step3", mockStep3Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        const data: any = getData(input)
        parallelize(
          saveProduct({ product: data.product }),
          saveVariant({ variant: data.variant })
        )
      })

      const workflowInput = "id_123"
      await workflow().run({
        input: workflowInput,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(1)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)

      expect(mockStep2Fn).toHaveBeenCalledTimes(1)
      expect(mockStep2Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep2Fn.mock.calls[0][0]).toEqual({ product: "product_1" })

      expect(mockStep3Fn).toHaveBeenCalledTimes(1)
      expect(mockStep3Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({ variant: "variant_2" })
    })

    it("should throw error when multiple handlers are defined for a single hook", async () => {
      const mockStep1Fn = jest.fn().mockImplementation(({ input }) => {
        return { id: input, product: "product_1", variant: "variant_2" }
      })

      const mockStep2Fn = jest.fn().mockImplementation(({ product }) => {
        product.product = "Saved product - " + product.product
        return product
      })

      const getData = createStep("step1", mockStep1Fn)
      const saveProduct = createStep("step2", mockStep2Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        const data = getData({ input })

        const hookReturn = createHook("changeProduct", {
          opinionatedPropertyName: data,
        })

        return new WorkflowResponse(saveProduct({ product: data }), {
          hooks: [hookReturn],
        })
      })

      workflow.hooks.changeProduct(() => {})
      expect(() => workflow.hooks.changeProduct(() => {})).toThrow(
        "Cannot define multiple hook handlers for the changeProduct hook"
      )

      const workflowInput = "id_123"
      const { result: final } = await workflow().run({
        input: workflowInput,
      })

      expect(final).toEqual({
        id: "id_123",
        variant: "variant_2",
        product: "Saved product - product_1",
      })
    })
  })

  describe("Using steps returning StepResponse", function () {
    afterEach(afterEach_)

    it("should compose a new workflow composed of retryable steps", async () => {
      const maxRetries = 1

      const mockStep1Fn = jest.fn().mockImplementation((input, context) => {
        const attempt = context.metadata.attempt || 0
        if (attempt <= maxRetries) {
          throw new Error("test error")
        }

        return new StepResponse({ inputs: [input], obj: "return from 1" })
      })

      const step1 = createStep({ name: "step1", maxRetries }, mockStep1Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        return new WorkflowResponse(step1(input))
      })

      const workflowInput = { test: "payload1" }
      const { result: workflowResult } = await workflow().run({
        input: workflowInput,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(2)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)
      expect(mockStep1Fn.mock.calls[1][0]).toEqual(workflowInput)

      expect(workflowResult).toEqual({
        inputs: [{ test: "payload1" }],
        obj: "return from 1",
      })
    })

    it("should compose a new workflow composed of retryable steps that should stop retries on permanent failure", async () => {
      const maxRetries = 1

      const mockStep1Fn = jest.fn().mockImplementation((input, context) => {
        return StepResponse.permanentFailure("fail permanently")
      })

      const step1 = createStep({ name: "step1", maxRetries }, mockStep1Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        return new WorkflowResponse(step1(input))
      })

      const workflowInput = { test: "payload1" }
      const { errors } = await workflow().run({
        input: workflowInput,
        throwOnError: false,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(1)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)

      expect(errors).toHaveLength(1)
      expect(errors[0]).toEqual({
        action: "step1",
        handlerType: "invoke",
        error: expect.objectContaining({
          message: "fail permanently",
        }),
      })
    })

    it("should compose a new workflow and execute it", async () => {
      const mockStep1Fn = jest.fn().mockImplementation((input) => {
        return new StepResponse({ inputs: [input], obj: "return from 1" })
      })
      const mockStep2Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return new StepResponse({
          inputs,
          obj: "return from 2",
        })
      })
      const mockStep3Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return new StepResponse({
          inputs,
          obj: "return from 3",
        })
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        const returnStep1 = step1(input)
        const ret2 = step2(returnStep1)
        return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
      })

      const workflowInput = { test: "payload1" }
      const { result: workflowResult } = await workflow().run({
        input: workflowInput,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(1)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)

      expect(mockStep2Fn).toHaveBeenCalledTimes(1)
      expect(mockStep2Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep2Fn.mock.calls[0][0]).toEqual({
        inputs: [workflowInput],
        obj: "return from 1",
      })

      expect(mockStep3Fn).toHaveBeenCalledTimes(1)
      expect(mockStep3Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        one: {
          inputs: [workflowInput],
          obj: "return from 1",
        },
        two: {
          inputs: [
            {
              inputs: [workflowInput],
              obj: "return from 1",
            },
          ],
          obj: "return from 2",
        },
      })

      expect(workflowResult).toEqual({
        inputs: [
          {
            one: {
              inputs: [workflowInput],
              obj: "return from 1",
            },
            two: {
              inputs: [
                {
                  inputs: [workflowInput],
                  obj: "return from 1",
                },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
    })

    it("should skip all steps in case of permanent failure", async () => {
      const logStepFn = jest.fn(async ({ input }: { input: object }) => {
        return new StepResponse("done")
      })

      const errorStep = createStep("perma-fail-step", async () => {
        return StepResponse.permanentFailure("FAIL")
      })

      const logStep = createStep("log-step", logStepFn)

      const fakeStepWorkflow = createWorkflow("fake-workflow", () => {
        const result = errorStep().config({
          skipOnPermanentFailure: true,
        })
        logStep({ input: { A: "123" } })
        logStep({ input: { A: "123 a" } }).config({ name: "other" })
        logStep({ input: { A: "123 b" } }).config({ name: "other_2" })
        logStep({ input: { A: "123 c" } }).config({ name: "other_3" })
        return new WorkflowResponse(result)
      })

      const { transaction } = await fakeStepWorkflow().run({
        input: 1,
      })

      expect(transaction.getState()).toEqual("done")
      expect(logStepFn).toHaveBeenCalledTimes(0)
    })

    it("should run same step multiple times", async () => {
      const log = createStep("log", async (input: number) => {
        return new StepResponse(input)
      })

      const sameStepWorkflow = createWorkflow("fake-workflow", () => {
        const a = log(1).config({ name: "aaaa" })
        const b = log(2) // without config on purpose
        const c = log(3).config({ name: "cccc" })
        return new WorkflowResponse([a, b, c])
      })

      const sameStepWorkflow2 = createWorkflow("fake-workflow-2", () => {
        const a = log(1)
        const b = log(2).config({ name: "bbbb" })
        const c = log(3).config({ name: "cccc" })
        return new WorkflowResponse([a, b, c])
      })

      const sameStepWorkflow3 = createWorkflow("fake-workflow-3", () => {
        const a = log(1).config({ name: "aaaa" })
        const b = log(2).config({ name: "bbbb" })
        const c = log(3)
        return new WorkflowResponse([a, b, c])
      })

      const { result } = await sameStepWorkflow().run()
      const { result: result2 } = await sameStepWorkflow2().run()
      const { result: result3 } = await sameStepWorkflow3().run()

      expect(result).toEqual([1, 2, 3])
      expect(result2).toEqual([1, 2, 3])
      expect(result3).toEqual([1, 2, 3])
    })

    it("should skip steps until the named step in case of permanent failure", async () => {
      const logStepFn = jest.fn(async ({ input }: { input: object }) => {
        return new StepResponse("done and returned")
      })

      const errorStep = createStep("perma-fail-step", async () => {
        return StepResponse.permanentFailure("FAIL")
      })

      const logStep = createStep("log-step", logStepFn)

      const fakeStepWorkflow = createWorkflow("fake-workflow", () => {
        errorStep().config({
          skipOnPermanentFailure: "other_2",
        })
        logStep({ input: { A: "123" } })
        logStep({ input: { A: "123 a" } }).config({ name: "other" })
        logStep({ input: { A: "123 b" } }).config({ name: "other_2" })
        const ret = logStep({ input: { A: "123 c" } }).config({
          name: "other_3",
        })
        return new WorkflowResponse(ret)
      })

      const { result, transaction } = await fakeStepWorkflow().run({
        input: 1,
      })

      expect(transaction.getState()).toEqual("done")
      expect(result).toEqual("done and returned")
      expect(logStepFn).toHaveBeenCalledTimes(2)
    })

    it("should compose a new workflow and skip steps depending on the input", async () => {
      const mockStep1Fn = jest.fn().mockImplementation((input) => {
        if (input === 1) {
          return StepResponse.skip()
        } else {
          return new StepResponse({ obj: "return from 1" })
        }
      })
      const mockStep2Fn = jest.fn().mockImplementation((input) => {
        if (!input) {
          return StepResponse.skip()
        }
        return new StepResponse({ obj: "return from 2" })
      })
      const mockStep3Fn = jest.fn().mockImplementation((inputs) => {
        return new StepResponse({
          inputs,
          obj: "return from 3",
        })
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        const returnStep1 = step1(input)
        const ret2 = step2(returnStep1)
        return new WorkflowResponse(
          step3({ one: returnStep1, two: ret2, input })
        )
      })

      const { result: workflowResult, transaction } = await workflow().run({
        input: 1,
      })

      expect(transaction.getFlow().hasSkippedSteps).toBe(true)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        input: 1,
      })

      expect(workflowResult).toEqual({
        inputs: {
          input: 1,
        },
        obj: "return from 3",
      })

      const { result: workflowResultTwo, transaction: transactionTwo } =
        await workflow().run({
          input: "none",
        })

      expect(transactionTwo.getFlow().hasSkippedSteps).toBe(false)
      expect(mockStep3Fn.mock.calls[1][0]).toEqual({
        one: {
          obj: "return from 1",
        },
        two: {
          obj: "return from 2",
        },
        input: "none",
      })

      expect(workflowResultTwo).toEqual({
        inputs: {
          one: {
            obj: "return from 1",
          },
          two: {
            obj: "return from 2",
          },
          input: "none",
        },
        obj: "return from 3",
      })
    })

    it("should compose two new workflows sequentially and execute them sequentially", async () => {
      const mockStep1Fn = jest.fn().mockImplementation((input, context) => {
        return new StepResponse({ inputs: [input], obj: "return from 1" })
      })
      const mockStep2Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return new StepResponse({
          inputs,
          obj: "return from 2",
        })
      })
      const mockStep3Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return new StepResponse({
          inputs,
          obj: "return from 3",
        })
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        const returnStep1 = step1(input)
        const ret2 = step2(returnStep1)
        return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
      })

      const workflow2 = createWorkflow("workflow2", function (input) {
        const returnStep1 = step1(input)
        const ret2 = step2(returnStep1)
        return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
      })

      const workflowInput = { test: "payload1" }
      const { result: workflowResult } = await workflow().run({
        input: workflowInput,
      })

      const workflow2Input = { test: "payload2" }
      const { result: workflow2Result } = await workflow2().run({
        input: workflow2Input,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(2)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)
      expect(mockStep1Fn.mock.calls[1][0]).toEqual(workflow2Input)

      expect(mockStep2Fn).toHaveBeenCalledTimes(2)
      expect(mockStep2Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep2Fn.mock.calls[0][0]).toEqual({
        inputs: [{ test: "payload1" }],
        obj: "return from 1",
      })
      expect(mockStep2Fn.mock.calls[1][0]).toEqual({
        inputs: [{ test: "payload2" }],
        obj: "return from 1",
      })

      expect(mockStep3Fn).toHaveBeenCalledTimes(2)
      expect(mockStep3Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
        two: {
          inputs: [{ inputs: [{ test: "payload1" }], obj: "return from 1" }],
          obj: "return from 2",
        },
      })
      expect(mockStep3Fn.mock.calls[1][0]).toEqual({
        one: { inputs: [{ test: "payload2" }], obj: "return from 1" },
        two: {
          inputs: [{ inputs: [{ test: "payload2" }], obj: "return from 1" }],
          obj: "return from 2",
        },
      })

      expect(workflowResult).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload1" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
      expect(workflow2Result).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload2" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload2" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
    })

    it("should compose two new workflows concurrently and execute them sequentially", async () => {
      const mockStep1Fn = jest.fn().mockImplementation((input, context) => {
        return new StepResponse({ inputs: [input], obj: "return from 1" })
      })
      const mockStep2Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return new StepResponse({
          inputs,
          obj: "return from 2",
        })
      })
      const mockStep3Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return new StepResponse({
          inputs,
          obj: "return from 3",
        })
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)

      const [workflow, workflow2] = await promiseAll([
        createWorkflow("workflow1", function (input) {
          const returnStep1 = step1(input)
          const ret2 = step2(returnStep1)
          return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
        }),

        createWorkflow("workflow2", function (input) {
          const returnStep1 = step1(input)
          const ret2 = step2(returnStep1)
          return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
        }),
      ])

      const workflowInput = { test: "payload1" }
      const { result: workflowResult } = await workflow().run({
        input: workflowInput,
      })

      const workflow2Input = { test: "payload2" }
      const { result: workflow2Result } = await workflow2().run({
        input: workflow2Input,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(2)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)
      expect(mockStep1Fn.mock.calls[1][0]).toEqual(workflow2Input)

      expect(mockStep2Fn).toHaveBeenCalledTimes(2)
      expect(mockStep2Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep2Fn.mock.calls[0][0]).toEqual({
        inputs: [workflowInput],
        obj: "return from 1",
      })
      expect(mockStep2Fn.mock.calls[1][0]).toEqual({
        inputs: [workflow2Input],
        obj: "return from 1",
      })

      expect(mockStep3Fn).toHaveBeenCalledTimes(2)
      expect(mockStep3Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
        two: {
          inputs: [{ inputs: [{ test: "payload1" }], obj: "return from 1" }],
          obj: "return from 2",
        },
      })
      expect(mockStep3Fn.mock.calls[1][0]).toEqual({
        one: { inputs: [{ test: "payload2" }], obj: "return from 1" },
        two: {
          inputs: [{ inputs: [{ test: "payload2" }], obj: "return from 1" }],
          obj: "return from 2",
        },
      })

      expect(workflowResult).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload1" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
      expect(workflow2Result).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload2" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload2" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
    })

    it("should compose two new workflows concurrently and execute them concurrently", async () => {
      const mockStep1Fn = jest.fn().mockImplementation((input, context) => {
        return new StepResponse({ inputs: [input], obj: "return from 1" })
      })
      const mockStep2Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return new StepResponse({
          inputs,
          obj: "return from 2",
        })
      })
      const mockStep3Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return new StepResponse({
          inputs,
          obj: "return from 3",
        })
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)

      const [workflow, workflow2] = await promiseAll([
        createWorkflow("workflow1", function (input) {
          const returnStep1 = step1(input)
          const ret2 = step2(returnStep1)
          return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
        }),

        createWorkflow("workflow2", function (input) {
          const returnStep1 = step1(input)
          const ret2 = step2(returnStep1)
          return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
        }),
      ])

      const workflowInput = { test: "payload1" }
      const workflow2Input = { test: "payload2" }

      const [{ result: workflowResult }, { result: workflow2Result }] =
        await promiseAll([
          workflow().run({
            input: workflowInput,
          }),
          workflow2().run({
            input: workflow2Input,
          }),
        ])

      expect(mockStep1Fn).toHaveBeenCalledTimes(2)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)
      expect(mockStep1Fn.mock.calls[1][0]).toEqual(workflow2Input)
      expect(mockStep1Fn.mock.calls[1]).toHaveLength(2)

      expect(mockStep2Fn).toHaveBeenCalledTimes(2)
      expect(mockStep2Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep2Fn.mock.calls[0][0]).toEqual({
        inputs: [workflowInput],
        obj: "return from 1",
      })
      expect(mockStep2Fn.mock.calls[1][0]).toEqual({
        inputs: [workflow2Input],
        obj: "return from 1",
      })

      expect(mockStep3Fn).toHaveBeenCalledTimes(2)
      expect(mockStep3Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
        two: {
          inputs: [{ inputs: [{ test: "payload1" }], obj: "return from 1" }],
          obj: "return from 2",
        },
      })
      expect(mockStep3Fn.mock.calls[1][0]).toEqual({
        one: { inputs: [{ test: "payload2" }], obj: "return from 1" },
        two: {
          inputs: [{ inputs: [{ test: "payload2" }], obj: "return from 1" }],
          obj: "return from 2",
        },
      })

      expect(workflowResult).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload1" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
      expect(workflow2Result).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload2" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload2" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
    })

    it("should compose a new workflow and execute it multiple times concurrently", async () => {
      const mockStep1Fn = jest
        .fn()
        .mockImplementation(function (input, context) {
          return new StepResponse({ inputs: [input], obj: "return from 1" })
        })
      const mockStep2Fn = jest.fn().mockImplementation(function (...inputs) {
        inputs.pop()
        return new StepResponse({
          inputs,
          obj: "return from 2",
        })
      })
      const mockStep3Fn = jest.fn().mockImplementation(function (...inputs) {
        inputs.pop()
        return new StepResponse({
          inputs,
          obj: "return from 3",
        })
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        const returnStep1 = step1(input)
        const ret2 = step2(returnStep1)
        return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
      })

      const workflowInput = { test: "payload1" }
      const workflowInput2 = { test: "payload2" }

      const [{ result: workflowResult }, { result: workflowResult2 }] =
        await promiseAll([
          workflow().run({
            input: workflowInput,
          }),
          workflow().run({
            input: workflowInput2,
          }),
        ])

      expect(mockStep1Fn).toHaveBeenCalledTimes(2)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)
      expect(mockStep1Fn.mock.calls[1]).toHaveLength(2)

      expect(mockStep2Fn).toHaveBeenCalledTimes(2)
      expect(mockStep2Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep2Fn.mock.calls[0][0]).toEqual({
        inputs: [workflowInput],
        obj: "return from 1",
      })

      expect(mockStep3Fn).toHaveBeenCalledTimes(2)
      expect(mockStep3Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
        two: {
          inputs: [{ inputs: [{ test: "payload1" }], obj: "return from 1" }],
          obj: "return from 2",
        },
      })

      expect(workflowResult).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload1" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
      expect(workflowResult2).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload2" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload2" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
    })

    it("should compose a new workflow with parallelize steps", async () => {
      const mockStep1Fn = jest.fn().mockImplementation((input, context) => {
        return new StepResponse({ inputs: [input], obj: "return from 1" })
      })
      const mockStep2Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return new StepResponse({
          inputs,
          obj: "return from 2",
        })
      })
      const mockStep3Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return new StepResponse({
          inputs,
          obj: "return from 3",
        })
      })
      const mockStep4Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return {
          inputs,
          obj: "return from 4",
        }
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)
      const step4 = createStep("step4", mockStep4Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        const returnStep1 = step1(input)
        const [ret2, ret3] = parallelize(step2(returnStep1), step3(returnStep1))
        return new WorkflowResponse(step4({ one: ret2, two: ret3 }))
      })

      const workflowInput = { test: "payload1" }
      const { result: workflowResult } = await workflow().run({
        input: workflowInput,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(1)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)

      expect(mockStep2Fn).toHaveBeenCalledTimes(1)
      expect(mockStep2Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep2Fn.mock.calls[0][0]).toEqual({
        inputs: [workflowInput],
        obj: "return from 1",
      })

      expect(mockStep3Fn).toHaveBeenCalledTimes(1)
      expect(mockStep3Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        inputs: [workflowInput],
        obj: "return from 1",
      })

      expect(mockStep4Fn).toHaveBeenCalledTimes(1)
      expect(mockStep4Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep4Fn.mock.calls[0][0]).toEqual({
        one: {
          inputs: [{ inputs: [{ test: "payload1" }], obj: "return from 1" }],
          obj: "return from 2",
        },
        two: {
          inputs: [{ inputs: [{ test: "payload1" }], obj: "return from 1" }],
          obj: "return from 3",
        },
      })

      expect(workflowResult).toEqual({
        inputs: [
          {
            one: {
              inputs: [
                { inputs: [{ test: "payload1" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
            two: {
              inputs: [
                { inputs: [{ test: "payload1" }], obj: "return from 1" },
              ],
              obj: "return from 3",
            },
          },
        ],
        obj: "return from 4",
      })
    })

    it("should compose a new workflow with parallelize steps and rollback them all in case of error", async () => {
      const step1CompensationFn = jest.fn().mockImplementation(() => {
        return new StepResponse("step1 compensation")
      })
      const step2CompensationFn = jest.fn().mockImplementation(() => {
        return new StepResponse("step2 compensation")
      })
      const step3CompensationFn = jest.fn().mockImplementation(() => {
        return new StepResponse("step3 compensation")
      })
      const step4CompensationFn = jest.fn().mockImplementation(() => {
        return new StepResponse("step4 compensation")
      })
      const mockStep1Fn = jest.fn().mockImplementation(() => {
        return new StepResponse("step1")
      })
      const mockStep2Fn = jest.fn().mockImplementation(() => {
        return new StepResponse("step2")
      })
      const mockStep3Fn = jest.fn().mockImplementation(() => {
        return new StepResponse("step3")
      })
      const mockStep4Fn = jest.fn().mockImplementation(() => {
        throw new Error("An error occured in step 4.")
      })

      const step1 = createStep(
        "step1",
        mockStep1Fn as unknown as StepFunction<never, StepResponse<string>>,
        step1CompensationFn
      )
      const step2 = createStep(
        "step2",
        mockStep2Fn as unknown as StepFunction<never, StepResponse<string>>,
        step2CompensationFn
      )
      const step3 = createStep(
        "step3",
        mockStep3Fn as unknown as StepFunction<never, StepResponse<string>>,
        step3CompensationFn
      )
      const step4 = createStep("step4", mockStep4Fn, step4CompensationFn)

      const workflow = createWorkflow("workflow1", function (input) {
        const [step1Res] = parallelize(step1(), step2(), step3(), step4({}))
        return new WorkflowResponse(step1Res)
      })

      await workflow.run({
        throwOnError: false,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(1)
      expect(mockStep2Fn).toHaveBeenCalledTimes(1)
      expect(mockStep3Fn).toHaveBeenCalledTimes(1)
      expect(mockStep4Fn).toHaveBeenCalledTimes(1)

      expect(step1CompensationFn).toHaveBeenCalledTimes(1)
      expect(step1CompensationFn.mock.calls[0][0]).toBe("step1")
      expect(step2CompensationFn).toHaveBeenCalledTimes(1)
      expect(step2CompensationFn.mock.calls[0][0]).toBe("step2")
      expect(step3CompensationFn).toHaveBeenCalledTimes(1)
      expect(step3CompensationFn.mock.calls[0][0]).toBe("step3")
      expect(step4CompensationFn).toHaveBeenCalledTimes(1)
      expect(step4CompensationFn.mock.calls[0][0]).not.toBeDefined()
    })

    it("should compose a new workflow with parallelize steps with config and rollback them all in case of error", async () => {
      const step1CompensationFn = jest.fn().mockImplementation(() => {
        return new StepResponse("step1 compensation")
      })
      const step2CompensationFn = jest.fn().mockImplementation(() => {
        return new StepResponse("step2 compensation")
      })
      const step3CompensationFn = jest.fn().mockImplementation(() => {
        return new StepResponse("step3 compensation")
      })
      const step4CompensationFn = jest.fn().mockImplementation(() => {
        return new StepResponse("step4 compensation")
      })
      const mockStep1Fn = jest.fn().mockImplementation(() => {
        return new StepResponse("step1")
      })
      const mockStep2Fn = jest.fn().mockImplementation(() => {
        return new StepResponse("step2")
      })
      const mockStep3Fn = jest.fn().mockImplementation(() => {
        return new StepResponse("step3")
      })
      const mockStep4Fn = jest.fn().mockImplementation(() => {
        throw new Error("An error occured in step 4.")
      })

      const step1 = createStep("step1", mockStep1Fn, step1CompensationFn)
      const step2 = createStep("step2", mockStep2Fn, step2CompensationFn)
      const step3 = createStep("step3", mockStep3Fn, step3CompensationFn)
      const step4 = createStep("step4", mockStep4Fn, step4CompensationFn)

      const workflow = createWorkflow("workflow1", function (input) {
        const [step1Res] = parallelize(
          step1({}).config({ name: "newStep1Name" }),
          step2({}),
          step3({}),
          step4({})
        )
        return new WorkflowResponse(step1Res)
      })

      await workflow.run({
        throwOnError: false,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(1)
      expect(mockStep2Fn).toHaveBeenCalledTimes(1)
      expect(mockStep3Fn).toHaveBeenCalledTimes(1)
      expect(mockStep4Fn).toHaveBeenCalledTimes(1)

      expect(step1CompensationFn).toHaveBeenCalledTimes(1)
      expect(step1CompensationFn.mock.calls[0][0]).toBe("step1")
      expect(step2CompensationFn).toHaveBeenCalledTimes(1)
      expect(step2CompensationFn.mock.calls[0][0]).toBe("step2")
      expect(step3CompensationFn).toHaveBeenCalledTimes(1)
      expect(step3CompensationFn.mock.calls[0][0]).toBe("step3")
      expect(step4CompensationFn).toHaveBeenCalledTimes(1)
      expect(step4CompensationFn.mock.calls[0][0]).not.toBeDefined()
    })

    it("should transform the values before forward them to the next step", async () => {
      const mockStep1Fn = jest.fn().mockImplementation((obj, context) => {
        const ret = new StepResponse({
          property: "property",
        })
        return ret
      })

      const mockStep2Fn = jest.fn().mockImplementation((obj, context) => {
        const ret = new StepResponse({
          ...obj,
          sum: "sum = " + obj.sum,
        })

        return ret
      })

      const mockStep3Fn = jest.fn().mockImplementation((param, context) => {
        const ret = new StepResponse({
          avg: "avg = " + param.avg,
          ...param,
        })
        return ret
      })

      const transform1Fn = jest
        .fn()
        .mockImplementation(({ input, step1Result }) => {
          const newObj = {
            ...step1Result,
            ...input,
            sum: input.a + input.b,
          }
          return {
            input: newObj,
          }
        })

      const transform2Fn = jest
        .fn()
        .mockImplementation(async ({ input }, context) => {
          input.another_prop = "another_prop"
          return input
        })

      const transform3Fn = jest.fn().mockImplementation(({ obj }) => {
        obj.avg = (obj.a + obj.b) / 2

        return obj
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)

      const mainFlow = createWorkflow("test_", function (input) {
        const step1Result = step1(input)

        const sum = transform(
          { input, step1Result },
          transform1Fn,
          transform2Fn
        )

        const ret2 = step2(sum)

        const avg = transform({ obj: ret2 }, transform3Fn)

        return new WorkflowResponse(step3(avg))
      })

      const workflowInput = { a: 1, b: 2 }
      await mainFlow().run({ input: workflowInput })

      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)

      expect(mockStep2Fn.mock.calls[0][0]).toEqual({
        property: "property",
        a: 1,
        b: 2,
        sum: 3,
        another_prop: "another_prop",
      })

      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        sum: "sum = 3",
        property: "property",
        a: 1,
        b: 2,
        another_prop: "another_prop",
        avg: 1.5,
      })

      expect(transform1Fn).toHaveBeenCalledTimes(1)
      expect(transform2Fn).toHaveBeenCalledTimes(1)
      expect(transform3Fn).toHaveBeenCalledTimes(1)
    })

    it("should compose a new workflow and access properties from steps", async () => {
      const mockStep1Fn = jest.fn().mockImplementation(({ input }, context) => {
        return new StepResponse({
          id: input,
          product: "product_1",
          variant: "variant_2",
        })
      })
      const mockStep2Fn = jest.fn().mockImplementation(({ product }) => {
        return new StepResponse({
          product: "Saved product - " + product,
        })
      })
      const mockStep3Fn = jest.fn().mockImplementation(({ variant }) => {
        return new StepResponse({
          variant: "Saved variant - " + variant,
        })
      })

      const getData = createStep("step1", mockStep1Fn)
      const saveProduct = createStep("step2", mockStep2Fn)
      const saveVariant = createStep("step3", mockStep3Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        const data: any = getData(input)
        parallelize(
          saveProduct({ product: data.product }),
          saveVariant({ variant: data.variant })
        )
      })

      const workflowInput = "id_123"
      await workflow().run({
        input: workflowInput,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(1)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)

      expect(mockStep2Fn).toHaveBeenCalledTimes(1)
      expect(mockStep2Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep2Fn.mock.calls[0][0]).toEqual({ product: "product_1" })

      expect(mockStep3Fn).toHaveBeenCalledTimes(1)
      expect(mockStep3Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({ variant: "variant_2" })
    })

    it("should throw error when multiple handlers for the same hook are defined", async () => {
      const mockStep1Fn = jest.fn().mockImplementation(({ input }) => {
        return new StepResponse({
          id: input,
          product: "product_1",
          variant: "variant_2",
        })
      })

      const mockStep2Fn = jest.fn().mockImplementation(({ product }) => {
        product.product = "Saved product - " + product.product
        return new StepResponse(product)
      })

      const getData = createStep("step1", mockStep1Fn)
      const saveProduct = createStep("step2", mockStep2Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        const data = getData({ input })

        const hookReturn = createHook("changeProduct", {
          opinionatedPropertyName: data,
        })

        return new WorkflowResponse(saveProduct({ product: data }), {
          hooks: [hookReturn],
        })
      })

      workflow.hooks.changeProduct(() => {})
      expect(() => workflow.hooks.changeProduct(() => {})).toThrow(
        "Cannot define multiple hook handlers for the changeProduct hook"
      )

      const workflowInput = "id_123"
      const { result: final } = await workflow().run({
        input: workflowInput,
      })

      expect(final).toEqual({
        id: "id_123",
        variant: "variant_2",
        product: "Saved product - product_1",
      })
    })
  })

  it("should compose a workflow that throws without crashing and the compensation will receive undefined for the step that fails", async () => {
    const mockStep1Fn = jest.fn().mockImplementation(function (input) {
      throw new Error("invoke fail")
    })

    const mockCompensateSte1 = jest.fn().mockImplementation(function (input) {
      return input
    })

    const step1 = createStep("step1", mockStep1Fn, mockCompensateSte1)

    const workflow = createWorkflow("workflow1", function (input) {
      return new WorkflowResponse(step1(input))
    })

    const workflowInput = { test: "payload1" }
    const { errors } = await workflow().run({
      input: workflowInput,
      throwOnError: false,
    })

    expect(errors).toHaveLength(1)
    expect(errors[0]).toEqual({
      action: "step1",
      handlerType: "invoke",
      error: expect.objectContaining({
        message: "invoke fail",
      }),
    })

    expect(mockStep1Fn).toHaveBeenCalledTimes(1)
    expect(mockCompensateSte1).toHaveBeenCalledTimes(1)

    expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)
    expect(mockCompensateSte1.mock.calls[0][0]).toEqual(undefined)
  })

  it("should compose a workflow that returns destructured properties", async () => {
    const step = function () {
      return new StepResponse({
        propertyNotReturned: 1234,
        property: {
          complex: {
            nested: 123,
          },
          a: "bc",
        },
        obj: "return from 2",
      })
    }

    const step1 = createStep("step1", step)

    const workflow = createWorkflow("workflow1", function () {
      const { property, obj } = step1()

      return new WorkflowResponse({ someOtherName: property, obj })
    })

    const { result } = await workflow().run({
      throwOnError: false,
    })

    expect(result).toEqual({
      someOtherName: {
        complex: {
          nested: 123,
        },
        a: "bc",
      },
      obj: "return from 2",
    })
  })

  it("should compose a workflow that returns an array of steps", async () => {
    const step1 = createStep("step1", () => {
      return new StepResponse({
        obj: "return from 1",
      })
    })
    const step2 = createStep("step2", () => {
      return new StepResponse({
        obj: "returned from 2**",
      })
    })

    const workflow = createWorkflow("workflow1", function () {
      const s1 = step1()
      const s2 = step2()

      return new WorkflowResponse([s1, s2])
    })

    const { result } = await workflow().run({
      throwOnError: false,
    })

    expect(result).toEqual([
      {
        obj: "return from 1",
      },
      {
        obj: "returned from 2**",
      },
    ])
  })

  it("should compose a workflow that returns an object mixed of steps and properties", async () => {
    const step1 = createStep("step1", () => {
      return new StepResponse({
        obj: {
          nested: "nested",
        },
      })
    })

    const step2 = createStep("step2", () => {
      return new StepResponse({
        obj: "returned from 2**",
      })
    })

    const workflow = createWorkflow("workflow1", function () {
      const { obj } = step1()
      const s2 = step2()

      return new WorkflowResponse([{ step1_nested_obj: obj.nested }, s2])
    })

    const { result } = await workflow().run({
      throwOnError: false,
    })

    expect(result).toEqual([
      {
        step1_nested_obj: "nested",
      },
      {
        obj: "returned from 2**",
      },
    ])
  })

  it("should cancel the workflow after completed", async () => {
    const mockStep1Fn = jest.fn().mockImplementation(function (input) {
      return new StepResponse({ obj: "return from 1" }, { data: "data" })
    })

    const mockCompensateSte1 = jest.fn().mockImplementation(function (input) {
      return input
    })

    const step1 = createStep("step1", mockStep1Fn, mockCompensateSte1)

    const workflow = createWorkflow("workflow1", function (input) {
      return new WorkflowResponse(step1(input))
    })

    const workflowInput = { test: "payload1" }
    const { transaction } = await workflow().run({
      input: workflowInput,
      throwOnError: false,
    })

    expect(mockStep1Fn).toHaveBeenCalledTimes(1)
    expect(mockCompensateSte1).toHaveBeenCalledTimes(0)

    await workflow().cancel({
      transaction,
      throwOnError: false,
    })

    expect(mockStep1Fn).toHaveBeenCalledTimes(1)
    expect(mockCompensateSte1).toHaveBeenCalledTimes(1)

    expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)
    expect(mockCompensateSte1.mock.calls[0][0]).toEqual({ data: "data" })
  })

  it("should throw if the same workflow is defined using different steps", async () => {
    const step1 = createStep("step1", () => {
      return new StepResponse({
        obj: {
          nested: "nested",
        },
      })
    })

    const step2 = createStep("step2", () => {
      return new StepResponse({
        obj: "returned from 2**",
      })
    })

    const step3 = createStep("step3", () => {
      return new StepResponse({
        obj: "returned from 3**",
      })
    })

    createWorkflow("workflow1", function () {
      const { obj } = step1()
      const s2 = step2()

      return new WorkflowResponse([{ step1_nested_obj: obj.nested }, s2])
    })

    expect(() =>
      createWorkflow("workflow1", function () {
        const { obj } = step1()
        const s2 = step2()
        step3()

        return new WorkflowResponse([{ step1_nested_obj: obj.nested }, s2])
      })
    ).toThrowError(
      `Workflow with id "workflow1" and step definition already exists.`
    )

    createWorkflow("workflow1", function () {
      const { obj } = step1()
      const s2 = step2()

      return new WorkflowResponse([{ step1_nested_obj: obj.nested }, s2])
    })
  })

  it("should emit grouped events once the workflow is executed and finished", async () => {
    const container = createMedusaContainer()
    container.register({
      [Modules.EVENT_BUS]: asValue({
        releaseGroupedEvents: jest
          .fn()
          .mockImplementation(() => Promise.resolve()),
        emit: jest.fn(),
      }),
    })

    const mockStep1Fn = jest
      .fn()
      .mockImplementation(
        async (input, { context: stepContext, container }) => {
          const eventBusService = container.resolve(Modules.EVENT_BUS)

          await eventBusService.emit(
            "event1",
            composeMessage("event1", {
              data: { eventGroupId: stepContext.eventGroupId },
              context: stepContext,
              object: "object",
              source: "service",
              action: "action",
            })
          )
        }
      )

    const step1 = createStep("step1", mockStep1Fn)

    const workflow = createWorkflow("workflow1", function (input) {
      step1(input)
    })

    await workflow(container).run({
      context: {
        eventGroupId: "event-group-id",
      },
    })

    expect(mockStep1Fn).toHaveBeenCalledTimes(1)
    expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)

    const eventBusMock = container.resolve<
      IEventBusModuleService & {
        emit: jest.Mock<any, any, any>
        releaseGroupedEvents: jest.Mock<any, any, any>
      }
    >(Modules.EVENT_BUS)
    expect(eventBusMock.emit).toHaveBeenCalledTimes(1)
    expect(eventBusMock.emit.mock.calls[0][0]).toEqual("event1")

    expect(eventBusMock.releaseGroupedEvents).toHaveBeenCalledTimes(1)
    expect(eventBusMock.releaseGroupedEvents.mock.calls[0][0]).toEqual(
      "event-group-id"
    )
  })

  it("should clear grouped events on fail state", async () => {
    const container = createMedusaContainer()
    container.register({
      [Modules.EVENT_BUS]: asValue({
        releaseGroupedEvents: jest
          .fn()
          .mockImplementation(() => Promise.resolve()),
        clearGroupedEvents: jest
          .fn()
          .mockImplementation(() => Promise.resolve()),
        emit: jest.fn(),
      }),
    })

    const mockStep1Fn = jest
      .fn()
      .mockImplementation(
        async (input, { context: stepContext, container }) => {
          const eventBusService = container.resolve(Modules.EVENT_BUS)

          await eventBusService.emit(
            "event1",
            composeMessage("event1", {
              data: { eventGroupId: stepContext.eventGroupId },
              context: stepContext,
              object: "object",
              source: "service",
              action: "action",
            })
          )
        }
      )

    const mockStep2Fn = jest.fn().mockImplementation(() => {
      throw new Error("invoke fail")
    })

    const step1 = createStep("step1", mockStep1Fn)
    const step2 = createStep("step2", mockStep2Fn)

    const workflow = createWorkflow("workflow1", function (input) {
      step1(input)
      step2(input)
    })

    await workflow(container).run({
      context: {
        eventGroupId: "event-group-id",
      },
      throwOnError: false,
    })

    const eventBusMock = container.resolve<IEventBusModuleService>(
      Modules.EVENT_BUS
    )

    expect(eventBusMock.emit).toHaveBeenCalledTimes(1)
    expect(eventBusMock.releaseGroupedEvents).toHaveBeenCalledTimes(0)
    expect(eventBusMock.clearGroupedEvents).toHaveBeenCalledTimes(1)
    expect(eventBusMock.clearGroupedEvents).toHaveBeenCalledWith(
      "event-group-id"
    )
  })

  it("should fail step and return response to compensate partial data", async () => {
    const maxRetries = 3

    const mockStep1Fn = jest.fn().mockImplementation(async (input, context) => {
      const ok: number[] = []
      const errors: number[] = []
      const toInsert = [1, 2, 3, 4, 5, 6, 7, 8]

      await promiseAll(
        toInsert.map(async (i) => {
          // fail on odd numbers
          if (i % 2 === 0) {
            ok.push(i)
            return i
          }

          errors.push(i)
          throw new Error("failed")
        })
      ).catch((e) => {})

      if (errors.length > 0) {
        return StepResponse.permanentFailure(
          "Error inserting " + errors.join(", "),
          ok
        )
      }

      return new StepResponse(ok)
    })

    const mockStep1CompensateFn = jest
      .fn()
      .mockImplementation((input, context) => {
        return input
      })

    const step1 = createStep(
      { name: "step1", maxRetries },
      mockStep1Fn,
      mockStep1CompensateFn
    )

    const step2 = createStep("step2", () => {
      throw new Error("failed")
    })

    const workflow = createWorkflow("workflow1", function (input) {
      step1(input)
      step2()
    })

    const workflowInput = { test: "payload1" }
    const { errors } = await workflow().run({
      input: workflowInput,
      throwOnError: false,
    })

    expect(mockStep1Fn).toHaveBeenCalledTimes(1)
    expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
    expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)

    expect(mockStep1CompensateFn.mock.calls[0][0]).toEqual([2, 4, 6, 8])

    expect(errors).toHaveLength(1)
    expect(errors[0]).toEqual({
      action: "step1",
      handlerType: "invoke",
      error: expect.objectContaining({
        message: "Error inserting 1, 3, 5, 7",
      }),
    })
  })

  it("should compose the workflow passing nested references to objects", async () => {
    const mockStep1Fn = jest.fn().mockImplementation(() => {
      return [1, 2, 3, 4, { obj: "return from 1" }]
    })
    const mockStep2Fn = jest.fn().mockImplementation((inp) => {
      return {
        a: {
          b: {
            c: [
              0,
              [
                {
                  inp,
                },
              ],
            ],
          },
        },
      }
    })

    const step1 = createStep("step1", mockStep1Fn) as any
    const step2 = createStep("step2", mockStep2Fn) as any

    const workflow = createWorkflow("workflow1", function () {
      const returnStep1 = step1()
      const ret2 = step2(returnStep1[4])
      return new WorkflowResponse(ret2.a.b.c[1][0].inp.obj)
    })

    const workflowInput = { test: "payload1" }
    const { result: workflowResult } = await workflow().run({
      input: workflowInput,
    })

    expect(workflowResult).toEqual("return from 1")
  })

  it("should compose a new workflow that skips steps on permanent failure [1]", async () => {
    const mockStep1Fn = jest.fn().mockImplementation(async () => {
      throw new Error("failed")
    }) as any
    const mockStep2Fn = jest.fn().mockImplementation(() => {
      return new StepResponse(true)
    }) as any
    const mockStep3Fn = jest.fn().mockImplementation(() => {
      return new StepResponse(true)
    }) as any
    const mockStep4Fn = jest.fn().mockImplementation(() => {
      return new StepResponse(true)
    }) as any

    const step1 = createStep(
      {
        name: "step1",
        skipOnPermanentFailure: "step3",
      },
      mockStep1Fn
    )
    const step2 = createStep("step2", mockStep2Fn)
    const step3 = createStep("step3", mockStep3Fn)
    const step4 = createStep("step4", mockStep4Fn)

    const workflow = createWorkflow("workflow1", function (input) {
      const ret1 = step1()
      const [ret2, ret3] = parallelize(step2(), step3())
      const ret4 = step4()
      return new WorkflowResponse({ ret1, ret2, ret3, ret4 })
    })

    const { result: workflowResult } = await workflow().run()

    expect(mockStep1Fn).toHaveBeenCalledTimes(1)
    expect(mockStep2Fn).toHaveBeenCalledTimes(0)
    expect(mockStep3Fn).toHaveBeenCalledTimes(1)
    expect(mockStep4Fn).toHaveBeenCalledTimes(1)

    expect(workflowResult).toEqual({
      ret1: undefined,
      ret2: undefined,
      ret3: true,
      ret4: true,
    })
  })

  it("should compose a new workflow that skips steps on permanent failure [2]", async () => {
    const mockStep1Fn = jest.fn().mockImplementation(async () => {
      throw new Error("failed")
    }) as any
    const mockStep2Fn = jest.fn().mockImplementation(() => {
      return new StepResponse(true)
    }) as any
    const mockStep3Fn = jest.fn().mockImplementation(() => {
      return new StepResponse(true)
    }) as any
    const mockStep4Fn = jest.fn().mockImplementation(() => {
      return new StepResponse(true)
    }) as any

    const step1 = createStep(
      {
        name: "step1",
        skipOnPermanentFailure: "step4",
      },
      mockStep1Fn
    )
    const step2 = createStep("step2", mockStep2Fn)
    const step3 = createStep("step3", mockStep3Fn)
    const step4 = createStep("step4", mockStep4Fn)

    const workflow = createWorkflow("workflow1", function (input) {
      const ret1 = step1()
      const [ret2, ret3] = parallelize(step2(), step3())
      const ret4 = step4()
      return new WorkflowResponse({ ret1, ret2, ret3, ret4 })
    })

    const { result: workflowResult } = await workflow().run()

    expect(mockStep1Fn).toHaveBeenCalledTimes(1)
    expect(mockStep2Fn).toHaveBeenCalledTimes(0)
    expect(mockStep3Fn).toHaveBeenCalledTimes(0)
    expect(mockStep4Fn).toHaveBeenCalledTimes(1)

    expect(workflowResult).toEqual({
      ret1: undefined,
      ret2: undefined,
      ret3: undefined,
      ret4: true,
    })
  })
})
